pipeline {
    agent any

    environment {
        // Define environment variables
        DIRECTORY_PATH = '/code'
        TESTING_ENVIRONMENT = 'staging-environment'
        PRODUCTION_ENVIRONMENT = 'production-environment'
        DEPLOY_DIR = '/Users/thech/Documents/Deakin/SIT753/Week 7, 8, 9/7.3HD/Project Reports/COMP4990-main/deploy'
        // Other Jenkins tools added - SonarQube
        SONARQUBE_SERVER = 'SonarQubeServer'
    }

    stages {
        // Stage 0: Checkout Github repo
        stage('Checkout') {
            steps {
                // Checkout the latest code from Git
                checkout scm
            }
        }

        // Stage 1: Build aertifact (ZIP)
        stage('Build') {
            steps {
                script {
                    echo "Creating a build artifact (ZIP) for PHP project"
                    // Clean up temporary and unnecessary files before any build
                    echo "Cleaning up unnecessary files..."
                    sh "rm -rf build && mkdir build"
                    sh "rm -rf .gitignore build/tmp build/*.log"

                    // Create directory and copy the files
                    sh "rm -rf build && mkdir build"
                    sh "cp -r * build/"
                    // Create ZIP file of the build directory
                    sh "cd build && zip -r ../artifact.zip ."
                    // Archive the aertifact
                    archiveArtifacts artifacts: "artifact.zip", fingerprint: true
                }
            }
        }

        // Stage 2: Unit and Integration Tests (PHPUnit)
        stage('Unit and Integration Tests') {
            steps {
                script {
                    // Run unit and integration tests using PHPUnit
                    echo "Running unit and integration tests"
                    // Install dependencies and ensure that tests exists
                    sh "composer install"
                    sh "vendor/bin/phpunit tests"
                }
            }
        }

        // Stage 3: Code Analysis using SonarQube
        stage('Code Analysis') {
            steps {
                script {
                    echo "Running SonarQube analysis"
                    // Grab credential in Jenkins credential
                    withCredentials([string(credentialsId: 'SONARQUBE_TOKEN', variable: 'SONARQUBE_TOKEN')]) {
                        sh """
                            sonar-scanner \
                            -Dsonar.projectKey=my-php-project \
                            -Dsonar.sources=. \
                            -Dsonar.host.url=http://localhost:9000 \
                            -Dsonar.login=${SONARQUBE_TOKEN}
                        """
                    }
                }
            }
        }

        // Stage 4: Security Scan using OWASP Dependency Check
        stage('Security Scan') {
            steps {
                script {
                    echo "Running security scan on PHP dependencies with OWASP Dependency-Check"
                    // Scan for known vulnerabilities in the dependency
                    sh "/opt/homebrew/bin/dependency-check --project PHP-Project --scan . --format HTML --out dependency-check-report"
                    // Archive the report
                    archiveArtifacts artifacts: "dependency-check-report/*.html", allowEmptyArchive: true
                }
            }
        }

        // Stage 5: Deploy to Staging
        stage('Deploy to Staging') {
            steps {
                script {
                    echo "Deploying to testing environment: ${env.TESTING_ENVIRONMENT}"
                    // This will simulate the deployment to staging by unpacking the ZIP artifact
                    sh "rm -rf \"${DEPLOY_DIR}/staging\" && mkdir -p \"${DEPLOY_DIR}/staging\""
                    sh "unzip artifact.zip -d \"${DEPLOY_DIR}/staging\""
                }
            }
        }

        // Stage 6: Integration Tests on Staging (manual approval needed)
        stage('Integration Tests on Staging') {
            steps {
                script {
                    echo "Waiting for manual approval..."
                    // Add timer and message for deployment approval
                    input message: "Approve deployment to production?", ok: "Deploy", timeout: 1 * 60 * 60, timeoutMessage: "Approval timed out"
                    echo "Approval received, proceeding with deployment."
                }
            }
        }

        // Stage 7: Deploy to Production
        stage('Deploy to Production') {
            steps {
                script {
                    echo "Deploying to production environment: ${env.PRODUCTION_ENVIRONMENT}"
                    // This will simulate the deployment to deployment by unpacking the ZIP artifact
                    sh "rm -rf \"${DEPLOY_DIR}/production\" && mkdir -p \"${DEPLOY_DIR}/production\""
                    sh "unzip artifact.zip -d \"${DEPLOY_DIR}/production\""
                }
            }
        }

        // Stage 8: Release to Production (Github Releases)
        stage('Release') {
            steps {
                script {
                    echo "Releasing application to GitHub"

                    dir("${DIRECTORY_PATH}") {
                        sh 'git status'
                        sh 'git tag -a v${BUILD_NUMBER} -m "Release v${BUILD_NUMBER}"'
                        sh 'git push origin --tags'
                        sh 'echo "Release application to production"'
                    }
                }
            }
        }

        // Stage 9: Monitoring and Alerting
        stage('Monitoring and Alerting') {
            steps {
                script {
                    echo "Configuring monitoring for production"
                    // Integration with monitoring tools - New Relic
                    sh 'newrelic-infra --status'
                    echo "New Relic is running"
                }
            }
        }
    }

    // Added post message to specify success and failure to execute the pipeline
    post {
        success {
            echo "Pipeline executed successfully"
        }
        failure {
            echo "Pipeline failed. Please check the logs for errors."
        }
    }
}
